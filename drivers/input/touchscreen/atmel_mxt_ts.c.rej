--- drivers/input/touchscreen/atmel_mxt_ts.c
+++ drivers/input/touchscreen/atmel_mxt_ts.c
@@ -3468,7 +3521,7 @@
 	}
 
 	dev_info(dev, "Identify firmware name :%s \n", fw_name);
-	disable_irq(data->irq);
+	mxt_disable_irq(data);
 
 	error = mxt_load_fw(dev, fw_name);
 	if (error) {
@@ -3489,7 +3542,7 @@
 	}
 
 	if (data->state == APPMODE) {
-		enable_irq(data->irq);
+		mxt_enable_irq(data);
 	}
 
 	kfree(fw_name);
@@ -5002,31 +5079,45 @@
 	input_sync(input_dev);
 }
 
-static int mxt_suspend(struct device *dev)
-{
-	int ret;
-	struct i2c_client *client = to_i2c_client(dev);
-	struct mxt_data *data = i2c_get_clientdata(client);
-	struct input_dev *input_dev = data->input_dev;
-
-	disable_irq(client->irq);
-
-	data->safe_count = 0;
-	cancel_delayed_work_sync(&data->update_setting_delayed_work);
-	cancel_delayed_work_sync(&data->disable_anticalib_delayed_work);
-	mxt_adjust_self_setting(data, true, TYPE_SELF_THR);
-	mxt_adjust_self_setting(data, true, TYPE_SELF_INTTHR_SUSPEND);
-	mxt_anti_calib_control(data, true);
-	mxt_self_recalib_control(data, true);
-
-	mutex_lock(&input_dev->mutex);
-
-	if (input_dev->users)
-		mxt_stop(data);
-
-	mutex_unlock(&input_dev->mutex);
-
-	mxt_clear_touch_event(data);
+ static int mxt_suspend(struct device *dev)
+ {
+
+
+        int ret;
+        struct i2c_client *client = to_i2c_client(dev);
+        struct mxt_data *data = i2c_get_clientdata(client);
+        struct input_dev *input_dev = data->input_dev;
+
+        dev_warn(dev, "Entering suspend\n");
+        if (data->is_suspended) {
+            return 0;
+        }
+        
+        
+        if (dt2w_switch == 1 ) {
+            dev_warn(dev, "Enabling irq wake\n");
+            enable_irq_wake(data->client->irq);
+            data->is_stopped = 1;
+        } else {
+                mxt_disable_irq(data);
+		dev_warn(dev, "Irq disabled\n");
+                data->safe_count = 0;
+                cancel_delayed_work_sync(&data->disable_anticalib_delayed_work);
+                mutex_lock(&input_dev->mutex);
+                if (input_dev->users)
+                    mxt_stop(data);
+                mutex_unlock(&input_dev->mutex);
+        }
+        
+        
+	
+ 	cancel_delayed_work_sync(&data->update_setting_delayed_work);
+ 	mxt_adjust_self_setting(data, true, TYPE_SELF_THR);
+ 	mxt_adjust_self_setting(data, true, TYPE_SELF_INTTHR_SUSPEND);
+ 	mxt_anti_calib_control(data, true);
+ 	mxt_self_recalib_control(data, true);
+
+ 	mxt_clear_touch_event(data);
 
 	if (data->regulator_vdd && data->regulator_avdd) {
 		ret = regulator_disable(data->regulator_avdd);
@@ -5073,17 +5170,24 @@
 		}
 	}
 
-	mutex_lock(&input_dev->mutex);
-
-	if (input_dev->users)
-		mxt_start(data);
+            mutex_lock(&input_dev->mutex);
+            if (input_dev->users)
+                mxt_start(data);
+            mutex_unlock(&input_dev->mutex);
+         
+        if (dt2w_switch == 1 ) {
+            disable_irq_wake(data->client->irq);
+            dev_warn(dev, "disabling irq wake\n");
+        } 
+       
+	mxt_enable_irq(data);
+        
+        data->is_suspended = false;
+	return 0;
+}
 
-	mutex_unlock(&input_dev->mutex);
 
-	enable_irq(client->irq);
 
-	return 0;
-}
 
 static int mxt_input_enable(struct input_dev *in_dev)
 {
@@ -5836,12 +5993,14 @@
 		goto err_free_object;
 
 	error = request_threaded_irq(client->irq, NULL, mxt_interrupt,
-			pdata->irqflags, client->dev.driver->name, data);
+			pdata->irqflags | IRQF_NO_SUSPEND, client->dev.driver->name, data);
 	if (error) {
 		dev_err(&client->dev, "Error %d registering irq\n", error);
 		goto err_free_input_device;
 	}
 
+	data->irq_enabled = true;
+
 	error = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);
 	if (error) {
 		dev_err(&client->dev, "Failure %d creating sysfs group\n",
@@ -5958,10 +6125,12 @@
 {
 	struct mxt_data *data = i2c_get_clientdata(client);
 
-	disable_irq(data->irq);
+	mxt_disable_irq(data);
 	data->state = SHUTDOWN;
 }
 
+static SIMPLE_DEV_PM_OPS(mxt_pm_ops, mxt_suspend, mxt_resume);
+
 static const struct i2c_device_id mxt_id[] = {
 	{ "qt602240_ts", 0 },
 	{ "atmel_mxt_ts", 0 },
